c는 배열끝 이상을 가면 이상한값이 나오기때문에 배열끝까지만 while문 돌리는게 좋다

memcpy(void *restrict dst, const void *restrict src, size_t n);
memmove(void *dst, const void *src, size_t len);  두 주소값이 교차할수있어도 copy는 잘 이루어져야함


dest(destination) : 복사되는 메모리의 주소
src(source) : 복사하는 메모리의 주소
size : 복사할 크기
return : 성공시 dest, 실패시 NULL
memcpy는 메모리의 내용을 직접 복사하고 memmove는 메모리의 내용을 임시저장소에 저장한후 복사


*ft_printf
[width 관련]
int a = printf("%2147483647d\n", 42);
printf("a : %d", a);
식으로 확인할수 있으며 width값은 int 값 보다 큰 값이 들어오면 overflow가 발생하여 width의 값이 - 가 되어 출력이 되지않는다 (width는 2147483647 - 1 값 까지만 가능)
overflow된 (-) 값이 다시 underflow되어서 (+) 값으로 돌려놓으면 (width가 무시된채로 = width에 0이 저장된채로) 정상적으로 출력된다 


[주소값 관련]
C언어의 특징은 메모리 접근입니다
메모리에 저장된 데이터는 타입을 지정해 주기 전까지는 그저 비트나열에 불과

주소값의 가장 중요한 특성은
1. unsigned
2. 몇진법이건 보통 정수형으로 표현

%p는 주솟값 16진수로 출력

unsigned 정수형중 void * 의 사이즈보다 큰 친구면 된다.
그런데 그게 어떤건지 보통 확정적이지 않으니 모른다
그러니 일단 가장 큰 친구를 가져다 쓰자 -> size_t
void * 이런곳에 담아서 쓸수도 있겠지만 포인터 변수에 담긴 주소를 직접 연산하기에는 좀 무섭죠


[컴파일 , 라이브러리 관련]
컴파일이 제대로 끝났다면 확장자가 .o인 filename.o파일이 만들어 질것이다. 
생성된 오브젝트 파일을 이용하여 라이브러리를 만들도록 한다.

이 때 사용하는 명령어는 "ar"로 라이브러리 작성에 사용된다. 아래와 같이 ar옵션 그리고 생성하고자 하는 라이브러리의 이름, 마지막으로 오브젝트 파일들의 이름을 나열한후 실행 한다.

(※ 윈도우에서 라이브러리 파일의 확장자는 .lib이지만 리눅스에서는 .a확장자를 지닌다.)
$ ar crv libfile.a filename.o

라이브러리 파일을 이용하여 실행 파일을 만들때 컴파일러의 옵션을 이용하는 방법이 있다. 이때 사용되는 옵션이 '-L' 과 '-l' 인데, -L의 경우에는 사용하고자 하는 라이브러리가 포함된 디렉토리 명을 명시하는 옵션이고, -l은 라이브러리의 이름을 적어주는 옵션이다. 이때 라이브러리의 이름은 lib라는 말과 확장자 .a를 생략하여 사용할수 있다. 즉, libfile.a의 경우 그냥 file이라고 쓰면 된다.

$ gcc -o executefile uselib.c -L. -l file